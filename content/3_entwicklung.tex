\chapter{Entwicklung}
\section{Backend}
\subsection{Projektstruktur}
Die Projektstruktur beziehungsweise die grobe Implementierung der Architektur wurde bereits in der Planung festgelegt. 
Der erste Schritt zur Erstellung war die Initiierung des Projekts mit dem sogenannten \texttt{Spring-Initializr}. 
Hierbei wurden folgende Dependencies hinzugefügt: \texttt{Spring-Web}, \texttt{Spring-Data-JPA}, \texttt{H2-Database}, \texttt{Microsoft-SQL-Server}, \texttt{Spring-Doc} und \texttt{Spring-Boot-DevTools}.

Die Projektstruktur wurde dann initial als drei Ordner \texttt{domain}, \texttt{application} und \texttt{infrastructure} verwirklicht.
Der Ordner \texttt{domain} enthält die Entitäten, der Ordner \texttt{application} die Services und der Ordner \texttt{infrastructure} die Controller.
Zusätzlich dazu wurde noch ein Konfigurationsordner erstellt, der die \texttt{Cors}-Einstellungen festlegt. 
Des Weiteren gab es noch ein SQL-Skript für die Testdaten und eine \texttt{application.properties}, um die Datenbank zu konfigurieren.

Die Fremdheit zu Java an sich erschwerte jedoch die initiale Umsetzung der Architektur. Die ursprüngliche Implementierung war nicht optimal und erfüllte
die Schichtenarchitektur nicht.

Im weiteren Verlauf wurde die Struktur so umgeändert, dass ich drei verschiedene Projekte angelegt habe: 
Ein Projekt \texttt{Domain} für die Entitäten und Repository-Interfaces, ein Projekt \texttt{Web} für die Controller und Datenbankkonfiguration, sowie ein Projekt \texttt{Data}, 
welches alle Services und die \texttt{Cors}-Konfiguration enthält. Jedes dieser Projekte hatte eine eigene \texttt{pom.xml}-Datei, die 
die Abhängigkeiten und den Build-Prozess regelt. So entsteht ein zusammenhängendes Projekt mit einer klaren Struktur und Trennung.

\subsection{Entitäten-Implementierung}
Die Entitäten sind das Grundgestein des Backends und auch der Datenbank.
Hier habe ich zuerst mit meinem Chef in mehreren Gesprächen definiert, welche Entitäten wir für das Projekt benötigen.

Die zu implementierenden Entitäten belaufen sich auf: \texttt{Tarif}, \texttt{Tarifbaustein}, \texttt{Tarifbaustein-Pricing}, 
\texttt{Produkt}, \texttt{Produkt-Pricing}, \texttt{Tafelsystem} und \texttt{Über\-schuss}.

% Im folgenden wurden die benötigten Felder für die Entitäten definiert. 
% // Hier die Klassen einfügen

Die Entitäten wurden als Klassen in dem Projekt \texttt{Domain} implementiert. Hierfür wurden zuerst die Properties der Klasse hinzugefügt und dann Getter und Setter geschrieben. 
Da die Primärschlüssel von allen Entitäten bis auf \texttt{Tarif} und \texttt{Produkt} aus mehreren Properties bestehen, habe ich zusätzlich die Annotation 
\texttt{@IdClass} hinzugefügt. Das heißt, ich habe für die Schlüssel eine extra Klasse erstellt, die das Interface \texttt{Serializable} implementiert und 
die Properties enthält. Dies ermöglicht mir ein Importieren des zusammengesetzten Schlüssels in die Entitäten.

Anschließend wurden die Entitäten mit der JPA-Annotation \texttt{@Entity} und \texttt{@Table} versehen, um die Verbindung zur Datenbank zu ermöglichen.

Der nächste Schritt war es, die Beziehungen zwischen den Entitäten hinzuzufügen. Hierbei gab es mehrere einfache 1:n Beziehungen: \texttt{Tarif} zu \texttt{Tarifbaustein}, \texttt{Tarifbaustein} zu \texttt{Tarifbaustein-Pricing} und \texttt{Produkt} zu \texttt{Produkt-Pricing}.

Die Beziehung zwischen \texttt{Tarifbaustein} und \texttt{Tafelsystem} sowie \texttt{Überschuss} waren jedoch ein bisschen komplexer. 
Hier hatte ich ursprünglich, anhand der Vorbesprechungen, jeweils drei n:m Beziehungen geplant. 
Dementsprechend habe ich diese Beziehungen als je drei Listen implementiert, die die Keys der jeweils anderen Entitäten als Fremdschlüssel nutzen.
Dies war für mich eher schwierig umzusetzen, da ich in Java noch nicht mit den Annotationen \texttt{@ManyToMany} und \texttt{@JoinTable} gearbeitet hatte.

In weiteren Gesprächen mit meinem Chef wurde dann letztlich deutlich, dass es keine drei n:m Beziehungen sind, sondern drei 1:n Beziehungen. 
Obwohl die Beziehungen bereits implementiert waren, fand ich die Notwendigkeit, die Entitäten anzupassen, gut. Diese Änderung nimmt nämlich einiges an Komplexität aus dem Projekt heraus und 
erleichterte mir somit alle weiteren Schritte zur Implementierung der Services und Controller.

Nachdem die Beziehungen definiert waren, habe ich bei den Kind-Entitäten die Annotation \texttt{@JsonIgnore} hinzugefügt, 
um bei der JSON-Serialisierung eine korrekte Darstellung der Beziehungen sicherzustellen und zyklische Abhängigkeiten zu vermeiden.

Im späteren Verlauf wurde noch eine Funktion zum String-Serialisieren der Properties hinzugefügt. Dies wird benötigt, um die Entitäten in die C-Datei schreiben zu können.

Zusätzlich wurden alle Getter und Setter entfernt, da ich im Seminar von dem Package \texttt{Lombok} erfahren habe und 
die \texttt{@Getter} und \texttt{@Setter} Annotationen die Klassen lesbarer machen.

\subsection{Interface-Initialisierung}
Die Interfaces für die Entitäten wurden in dem Projekt \texttt{Domain} erstellt. 
Danach wurden die Annotation \texttt{@Repository} hinzugefügt, dies kennzeichnet intern die Klasse als Repository und ermöglicht die Verwendung der JPA-Annotationen. 

Spring Data JPA bietet zusätzlich die Möglichkeit diverse Grundfunktionen zu implementieren. Hierfür erweitert man das die eigenen Interfaces mit dem Spring Interface \texttt{JpaRepository}. 
Diese Erweiterung wurde in den Interfaces hinzugefügt und die Entitäten als Typenparameter übergeben.

Die Funktionen, auf die man nun in allen Entitäten zugreifen kann, sind unter anderem \texttt{save}, \texttt{findAll}, \texttt{deleteAll}, \texttt{saveAll}, \texttt{getAll}, \texttt{getById} und viele weitere.
Diese Möglichkeit, die CRUD-Operationen so zu implementieren, erspart einem viel Zeit und Arbeit.

Als extra Query habe ich noch eine Funktion zum Finden von leeren Überschüssen und Tafelsystemen hinzugefügt. Leer bedeutet in diesem Fall, dass die Liste der Tarifbausteine leer ist.
Dies wird benötigt, um verwahrloste Kind-Entitäten zu finden und zu löschen.

Der Aufbau dieser Query ist folgendermaßen:

\lstinputlisting[language=Java,caption={Interface Query},captionpos=b]{listings/interface-method.java}

Des Weiteren habe ich noch eine Query findMinUesel() hinzugefügt, um das momentan niedrigste Üsel zu finden.
Diese Funktion wird benötigt, da in einer anderen Funktion Überschüsse kopiert werden und die Generierung der Üsel 
manuell geschehen muss. 

\subsection{Service-Implementierung}
Die Services sind die Klassen, die die Logik enthalten. Hier werden die Daten verarbeitet und die Operationen durchgeführt.
Hier wurden für alle Entitäten jeweils eine Service-Klasse erstellt. Um diese als Service zu kennzeichen, wurde die Annotation \texttt{@Service} hinzugefügt.
Zusätzlich wurde noch ein Service für die Suche und ein weiterer für die Generierung der C-Datei hinzugefügt.

Die Grundstruktur der Entitäten-Service ist immer gleich. Zuerst wird das Repository injected, um auf die Methoden des JpaRepositories zugreifen zu können. Ich habe mich hierbei für die sogenannte Dependency Injection entschieden.
In Java sieht das beispielsweise so aus:

\lstinputlisting[language=Java,caption={Dependency Injection},captionpos=b]{listings/dependency-injection.java}

Diese Variante fördert eine lose Kopplung, verbessert die Testbarkeit, erhöht die Flexibilität durch austauschbare Implementierungen 
und vereinfacht das Konfigurationsmanagement, was insgesamt zu wartbarer und anpassungsfähiger Software führt. \cite{seemann2019dependency}

Danach werden die CRUD-Operationen, die in den Interfaces schon vorgegeben wurden, implementiert.

Hierfür reicht es aus einen Methodenrumpf zu definieren und dann die jeweilige Methode des Repositories aufzurufen.
Anhand des Beispiels Produkt-Service sieht das so aus:

\lstinputlisting[language=Java,caption={Service Implementierung},captionpos=b]{listings/service.java}

Im weiteren Verlauf wurde für den Tarif-Service noch die Methode zum Löschen von Elternlosen Tafelsystemen und Überschüssen hinzugefügt.
Diese Funktion wird aufgerufen, wenn ein Tarif gelöscht wird.

Die meisten zusätzlichen Funktionen wurden im Überschuss-Service hinzugefügt. Hier wurde die Funktion \texttt{changeUeberschussSatz()} hinzugefügt, um die aktuelle Gesamtverzinsung jährlich 
ändern zu können. Besonderheit bei dieser Funktion ist die benötigte Annotation \texttt{@Transactional}. Diese Annotation sorgt dafür, dass bei Fehlern alle Änderungen zurückgerollt werden.

Um die Anforderung zu erfüllen, dass Überschüsse fortgeschrieben werden können wenn der Gesamtzins unverändert bleibt, wurde die Funktion \texttt{overWriteUesy()} hinzugefügt.
Diese Funktion legt eine Deep-Copy von dem mitgegebenen Überschuss an, setzt das Datum des alten Überschusses auf das Ende des aktuellen Jahres, und das Datum des neuen 
Überschusses auf das Ende des nächsten Jahres. Danach werden beide Überschüsse gespeichert.

Die vorherige Funktion spiegelt letztlich den Prozess wider, Überschüsse manuell zu kopieren und zu verändern. Ein Problem hierbei ist jedoch, dass nicht alle Überschüsse geändert werden.
Jedoch muss man diese auch fortschreiben ins nächste Jahr. Hierfür wurde eine weitere Funktion \texttt{updateUnchangedUesy()}  hinzugefügt. Diese Funktion sucht alle Überschüsse, bei dem kein 
deklariertBis mit dem folgenden Jahr als Wert existiert und setzt dann das deklariertBis auf das Ende des nächsten Jahres.

Eine weitere notwendige Funktion war die \texttt{splitUesyHistory()}. Diese Funktion wird benötigt, um Überschüsse aufzutrennen. Der Hintergrund ist hierbei der folgende: Momentan werden Überschüsse
manchmal für mehrere Tarife genommen, da die Werte gleich sein sollen. Jedoch können die Anforderungen an die Überschüsse sich ändern. Da wir die Historie der Überschüsse benötigen, muss 
diese also aufgeteilt und kopiert werden. Dafür ist diese Funktion zuständig.

Wie zuvor erwähnt wurden noch zwei weitere Services implementiert. Der \texttt{CFile\-Generation\-Service} und der \texttt{SearchService}.

Der \texttt{CFileGenerationService} implementiert eine generische Funktion für die 
Generierung des C-Files. Diese Methode wird dann in den jeweilige Entität-Services aufgerufen. Hierfür war es zusätzlich notwendig den CFileGenerationService zu injecten.

Der \texttt{SearchService} implementiert ebenfalls eine generische Funktion. Für die Suche gibt es zwei Optionen: direkte Suche eines Wertes in allen Feldern oder Suche eines Wertes in einem 
bestimmten Feld. Die Methode berücksichtigt dabei, ob die Suchanfrage in der Form \texttt{key=value} oder einfach nur \texttt{value} vorliegt. 
Für jede Entität gibt es einen eigenen Controller-Endpunkt zur Durchführung der Suche.

\subsection{Controller-Implementierung}
Die Controller sind die Schnittstelle zwischen dem Frontend und dem Backend. Hier werden die REST-Apis implementiert, die die Daten an das Frontend senden.
Der erste Schritt war die Implementierung aller Controller Klassen. Hierfür erstellt man eine normale Java Klasse und annotiert diese mit \texttt{@RestController} und \texttt{@RequestMapping("path")}.
Wie bei den anderen bis jetzt erwähnten Annotationen, diene diese der Kennzeichnung für Spring.

Der nächste Schritt war die Injection der Services in die Controller. Das läuft genauso ab, wie in den Services.

Der letzte Schritt war die Implementierung der REST-Endpunkte. Hierfür habe ich in jedem Controller die Schnittstellen \texttt{getAll}, \texttt{getById}, \texttt{generateCFile}, \texttt{create}, \texttt{update}, 
\texttt{deleteById} und \texttt{search} hinzugefügt.
Bei jeder Schnittstelle musste noch die passende Annotation, die den Request-Type angibt, hinzugefügt werden.

Im späteren Verlauf kamen noch weitere spezifischere Endpunkte hinzu. Dazu gehören zum Beispiel die Endpunkte zum Deaktivieren von Tarifen und Produkten oder 
zum ändern der aktuellen Gesamtverzinsung.
\section{Frontend}
Das Frontend, also die Benutzeroberfläche, hat mehr Zeit in Anspruch genommen, als ursprünglich angenommen.

Angefangen habe ich indem ich ein neues Angular Projekt, mithilfe des Command-Line-Interface, erstellt habe. Dies erstellt eine Grundstruktur für das Projekt und definiert benötigte Abhängigkeiten.

Danach war es mein erstes Ziel, die Api-Definition und einen Service zu erstellen, über den die Kommunikation zum Backend läuft. Hierfür habe ich zuerst die Api-Definition mit dem Swagger-Editor erstellt und in 
das Projekt eingefügt. Danach habe ich den Service erstellt der die Grundkonfiguration für die Kommunikation enthält.
Die Klasse ist folgendermaßen aufgebaut:
\lstinputlisting[language=javascript,caption={Api-Service},captionpos=b]{listings/api-service.ts}

Zusätzlich habe ich noch einen HTTP-Interceptor hinzugefügt. Dieser fängt alle HTTP-Requests ab. Momentan wird dieser nur genutzt um zwischen 
Aufbau und Abbau eines Requests eine Ladeanimation anzuzeigen. Jedoch ist es denkbar zukünftig, dass darin auch eine Fehlerbehandlung implementiert wird.

Mein nächster Schritt war es für jede Entität eine Komponente zu erstellen. In diesen habe ich dann eine Tabelle hinzugefügt, die alle Daten enthält.

Um zu diesen Komponenten navigieren zu können, habe ich eine Navigationsleiste hinzugefügt. Für das Routing hat Angular ein eigenes System. Dort werden alle Routen
und die dazugehörigen Komponenten definiert. Anschließend fügt man diese in der \texttt{app.config.ts} als Provider hinzu.

Im weiteren Verlauf habe ich zwei Buttons in der Tarif- und Produkt-Komponente implementiert. Beim ersten Klick auf diesen Button wird der Tarif beziehungsweise das Produkt deaktiviert und beim zweiten Klick
wird er gelöscht. Nachdem ersten Klick wird zusätzlich der zweite Button sichtbar. Dieser reaktiviert den Tarif beziehungsweise das Produkt.

Danach war es wichtig neue Entitäten hinzufügen zu können. Hierfür habe ich einen weiteren Button hinzugefügt. Dieser öffnet ein Dialog-Fenster mit allen Inputs die für die Entität
notwendig ist. Um das zu ermöglichen habe ich für jede Entität eine Form-Komponente hinzugefügt. Das Dialog-Fenster um einen neuen Tarif hinzuzufügen besteht also aus mehreren 
Form-Komponenten. 

In den Form-Komponenten habe ich dann zum einen noch die Validierung der Inputs hinzugefügt, damit nur richtige Werte gespeichert werden. Und zum anderen habe ich noch Funktionen zum
Löschen und hinzufügen von Tarifbausteinen und Tarifbaustein-Pricings hinzugefügt. Dies ist notwendig da ein Tarif mehrere dieser Entitäten besitzen kann. Zusätzlich habe ich noch Logik hinzugefügt,
damit die Fremdschlüssel der Kinder automatisch mit dem Eltern-Primärschlüssel synchronisiert werden.

Bei der Implementierung des Dialog-Fensters war die größte Herausforderung die Kommunikation zwischen den Komponenten. Um das zu lösen habe ich die \texttt{ParentFormGroup} immer als Input in die 
Komponenten mitgegeben.

Als nächsten Punkt musste die Möglichkeit hinzugefügt werden, die Entitäten verändern zu können. Hierfür habe ich wieder einen Button 
implementiert, der die Felder zu Inputs macht und diese dann die veränderten Daten ans Backend sendet. 

Hier ist mir aufgefallen, dass meine momentane Implementierung der Entitäten im Frontend nicht optimal ist. In der momentanen Umsetzung
muss ich alle Erweiterungen für jede Entität hinzufügen. Das ist nicht nur sehr aufwendig, sondern auch fehleranfällig.

Meine Lösung war hierfür, dass ich eine neue Komponenten erstellt habe, die die Felder der Entität als Objekt übergeben bekommt und dann dynamisch
alle Felder darstellt. Das sorgt dafür, dass die Implementierung nur noch in einer Komponente stattfindet und somit die Erweiterungen oder Änderungen
nur an einer Stelle gemacht werden müssen.

Danach habe ich noch die restliche Funktionen hinzugefügt. Dazu gehören folgende Funktionen: \texttt{overWriteUesy()}, \texttt{changeGesamtZins()}, \texttt{splitUesyHistory()},
\texttt{updateUnchangedUesy()} und \texttt{search()}. 

Die Suche ist wieder eine eigene Komponente und auch Service, der die Entität als Input bekommt und so entscheidet, an welche Api die Anfrage geschickt wird.

Nach der Implementierung der Suche gab es nur noch kleine Erweiterungen und Verbesserungen. Ein Beispiel hierfür ist eine Combo-Box, ein Dropdown-Menü mit integrierter Suche,
um die Auswahl der Tarifbausteine, Überschüsse und Tafelsysteme zu erleichtern.
% TODO Frontend
\section{Datenbank}
Die Datenbank wurde bislang noch nicht aufgesetzt. Für die Entwicklung wurde jedoch eine H2-Datenbank verwendet. 

Diese ist eine In-Memory Datenbank. Das heißt, dass die Datenbank nur so lange existiert, wie die Anwendung läuft.
Das hat den Vorteil, dass die Datenbank bei jedem Start der Anwendung neu initialisiert wird und somit immer der gleiche Ausgangszustand herrscht.
Die Option die Daten in einer Datei zu speichern, wurde nicht genutzt, da ein Zurücksetzen nach einem Build-Prozess besser für die Entwicklung geeignet ist.

Um die Daten zu befüllen, wurde ein SQL-Script mit ein paar Test Daten für jede Entität geschrieben. Dieses Script wird bei jedem Start ausgeführt und
füllt dann die Datenbank.

Die Datenbank wird dann in der weiteren Tätigkeit als Werkstudent beantragt, fertig aufgesetzt und verbunden.


